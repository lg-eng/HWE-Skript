{
  "hash": "2f3883e9d1d273c0a2e049bc8d44769f",
  "result": {
    "markdown": "# Boolesche Algebra  \n\n::: {.cell execution_count=1}\n``` {.python .cell-code code-fold=\"true\"}\n#import sys\n# adding Folder_2 to the system path\n#sys.path.insert(0, '../../../Common/QuartoBookHelpers')\n#import QuartoBookHelpers\n\nfrom IPython.display import Markdown, Latex\n\nfrom sympy import *\nimport sympy.physics.units as u\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom quantiphy import Quantity\nimport re\n\nclass MySymbol(Symbol):\n    def __new__(cls, name, description='',unit='',value=''):\n        obj = Symbol.__new__(cls, name)\n        obj.description = description\n        obj.unit = unit\n        obj.value = value\n        \n        return obj\n\nclass MyFunction(Function):\n    def __new__(cls, name, description='',unit='',value=''):\n        obj = Function.__new__(cls, name)\n        obj.description = description\n        obj.unit = unit\n        obj.value = value\n        \n        return obj\n        \nclass QBookHelpers():\n    def print_description(dic):\n        for vari in dic:\n            display(Markdown(f'${latex(vari)}$' + ' ... ' + vari.description))\n            \n    def print_equation(eq,**kwargs):\n        #print(kwargs)\n        if kwargs != {}:\n            label = kwargs['label']\n            #print(label)\n            display(Markdown(f'$$\\n{latex(eq)}\\n$${{#' + label + f'}}'))\n        else:      \n            display(Markdown(f'$$\\n{latex(eq)}\\n$${{#eq-Dummy}}'))\n            \n    def print_values(dic,**kwargs):\n        for vari in dic:\n            try:\n                QuantValue = Quantity(vari.value,str(vari.unit.abbrev))\n            except:\n                QuantValue = Quantity(vari.value)\n            \n            quant_string = QuantValue.render(prec=2)\n            val = quant_string.split(' ')[0]\n            if quant_string[-1].isdigit():\n                uni = ''\n            else:\n                try:\n                    uni = quant_string.split(' ')[1]\n                except:\n                    uni = quant_string[-1]\n            #print(re.split('(\\d+)',QuantValue.render(prec=2)))\n            #uni = re.split('(\\d+)',QuantValue.render(prec=2))[-1]\n            #uni = ''\n            #val = re.split('(\\d+)',QuantValue.render(prec=2))[1]\n            #val = QuantValue.render(prec=2)\n\n            if uni.find('ohm') >=0:\n                uni = '\\ \\mathrm{' + uni.replace('ohm','\\Omega') + '}'\n                disp_string = f'$${latex(vari)}' + ' = ' + latex(val) + ' ' + str(uni) + f'$$' \n            else:\n                disp_string = f'$${latex(vari)}' + ' = ' + latex(val) + ' \\ ' + latex(uni) + f'$$' \n            \n            if kwargs != {}:\n                label = kwargs['label']\n                disp_string = disp_string + f'{{#' + label + f'}}'\n\n            \n            display(Markdown(disp_string))\n\n            #display(Markdown(f'${latex(vari)}$' + ' = ' + str(vari.value) + f'$\\ {latex(vari.unit)}$' ))            \n            #display(Markdown(f'${latex(vari)}$' + ' = ' + str(\"%.2f\" % round(vari.value, 2)) + f'$\\ {latex(vari.unit)}$' ))\n            #display(Markdown(f'$${latex(vari)}' + ' = ' + latex(QuantValue.render()) + f'$$' ))\n            #display(Markdown(f'$${latex(vari)}' + ' = ' + latex(quant) + f'$$' ))\n            #display(Markdown(f'$${latex(vari)}' + ' = ' + str(vari.value) + f'\\ {latex(vari.unit)}$$' ))\n\n            \n    def calculate_num_value(eqn):\n        replacement = {}\n        for sym in eqn.rhs.free_symbols:\n            case = {sym:sym.value}\n            replacement.update(case)\n        #print(replacement)\n        #return Eq(eqn.lhs,eqn.rhs.evalf(subs=replacement))\n        eqn.lhs.value = eqn.rhs.evalf(subs=replacement)\n        #display(eqn.lhs.value)\n\n    def logic_parser(eqn):\n        return str(eqn).replace('&','and').replace('|','or').replace('~','not')\n\n```\n:::\n\n\n## Von der Wahrheitstabelle zur Booleschen Gleichung  \nEs soll mittels Boolescher Algebra die einfachste Boolesche Gleichung aus der Wahrheitstabelle ermittelt werden. \n\n### Wahrheitstabelle \n\n|Nummer| D | C | B | A | Y | Minterm | Verwendet |\n|-| - | - | - | - | - | ------- | - |\n|1| 0 | 0 | 0 | 0 | 0 |     \\-   | \\- |\n|2| 0 | 0 | 0 | 1 | 1 | $\\bar{D} \\land \\bar{C} \\land \\bar{B} \\land   {A}$    | x |\n|3| 0 | 0 | 1 | 0 | 0 | \\-      | \\- |\n|4| 0 | 0 | 1 | 1 | 1 |  $\\bar{D} \\land \\bar{C} \\land {B} \\land   {A}$      | xy |\n|5| 0 | 1 | 0 | 0 | 0 | \\-      | \\- |\n|6| 0 | 1 | 0 | 1 | 1 | $\\bar{D} \\land {C} \\land \\bar{B} \\land   {A}$     | x |\n|7| 0 | 1 | 1 | 0 | 1 | $\\bar{D} \\land {C} \\land {B} \\land   \\bar{A}$     | - |\n|8| 0 | 1 | 1 | 1 | 1 | $\\bar{D} \\land {C} \\land {B} \\land   {A}$      | y |\n|9| 1 | 0 | 0 | 0 | 0 | \\-      | \\-|\n|10| 1 | 0 | 0 | 1 | 1 | ${D} \\land \\bar{C} \\land \\bar{B} \\land   {A}$      |x|\n|11| 1 | 0 | 1 | 0 | 0 | \\-      |\\-|\n|12| 1 | 0 | 1 | 1 | 1 | ${D} \\land \\bar{C} \\land {B} \\land   {A}$      |y|\n|13| 1 | 1 | 0 | 0 | 1 | ${D} \\land {C} \\land \\bar{B} \\land   \\bar{A}$       |\\-|\n|14| 1 | 1 | 0 | 1 | 1 | ${D} \\land {C} \\land \\bar{B} \\land   {A}$       |-|\n|15| 1 | 1 | 1 | 0 | 0 | \\-      |\\-|\n|16| 1 | 1 | 1 | 1 | 0 | \\-      |\\-|\n\n\n### Vereinfachen durch Vergleich von Thermen mit nur einem Unterschied \nDa gilt $A \\lor A = A$ (Idempotenzgesetze der Disjunktion) können Therme mehrfach verwendet werden. Es muss nur so lange verglichen werden bis alle Terme einmal benutzt wurden! Gibt es zu einem Term, keinen weiteren Term mit nur einer abweichenden negation so ist dieser vollständig in das Ergebnis zu übernehmen.\n \n$(\\bar{D} \\land \\bar{C} \\land \\bar{B} \\land   {A}) \\lor (\\bar{D} \\land \\bar{C} \\land {B} \\land   {A}) = \\bar{D} \\land \\bar{C} \\land   {A}$ x  \n$(\\bar{D} \\land \\bar{C} \\land \\bar{B} \\land   {A}) \\lor (\\bar{D} \\land {C} \\land \\bar{B} \\land   {A}) = \\bar{D}  \\land \\bar{B} \\land   {A}$ y  \n$(\\bar{D} \\land \\bar{C} \\land \\bar{B} \\land   {A}) \\lor ({D} \\land \\bar{C} \\land \\bar{B} \\land   {A}) =  \\bar{C} \\land \\bar{B} \\land   {A}$ z  \n$(\\bar{D} \\land \\bar{C} \\land {B} \\land   {A}) \\lor (\\bar{D} \\land {C} \\land {B} \\land   {A})  = \\bar{D} \\land {B} \\land   {A}$ y  \n$(\\bar{D} \\land \\bar{C} \\land {B} \\land   {A}) \\lor ({D} \\land \\bar{C} \\land {B} \\land   {A}) =  \\bar{C} \\land {B} \\land   {A}$ z  \n$(\\bar{D} \\land {C} \\land {B} \\land   \\bar{A}) \\lor (\\bar{D} \\land {C} \\land {B} \\land   {A}) = \\bar{D} \\land {C} \\land {B}$  \n$({D} \\land \\bar{C} \\land {B} \\land   {A}) \\lor ({D} \\land \\bar{C} \\land \\bar{B} \\land   {A}) = {D} \\land \\bar{C}  \\land   {A}$ x  \n$({D} \\land {C} \\land \\bar{B} \\land   \\bar{A}) \\lor ({D} \\land {C} \\land \\bar{B} \\land   {A}) = {D} \\land {C} \\land \\bar{B}$  \n\nNun wird erneut verglichen bis jeder Therm mindestens einmal verwendet wurde.  Gibt es zu einem Term keinen weiteren Term mit nur einer abweichenden negation so ist dieser vollständig in das Ergebnis zu übernehmen.  \n$(\\bar{D} \\land \\bar{C} \\land   {A}) \\lor ({D} \\land \\bar{C}  \\land   {A}) =  \\bar{C}  \\land   {A}$  \n$(\\bar{D}  \\land \\bar{B} \\land {A}) \\lor (\\bar{D} \\land {B} \\land   {A}) = \\bar{D} \\land   {A}$  \n$(\\bar{C} \\land \\bar{B} \\land   {A}) \\lor (\\bar{C} \\land {B} \\land   {A}) = \\bar{C}  \\land   {A}$  \nMit dem Idempotenzgesetze der Disjunktion $ A \\lor A = A$ kann der letzte dieser Term weg gelassen werden, da er bereits in der ersten Zeile vorkommt.\n\nDas Ergebnis:  \n$$Y =  (\\bar{C}  \\land   {A}) \\lor (\\bar{D} \\land   {A})  \\lor (\\bar{D} \\land {C} \\land {B}) \\lor ({D} \\land {C} \\land \\bar{B})$$  {#eq-bool2}\n\n\n\n### Überprüfung\nZur Überprüfung wird das Ergebnis mittels Sympy berechnet.\n\n::: {#tbl-wahrheitstabelle .cell tbl-cap='Wahrheitstabelle' execution_count=2}\n``` {.python .cell-code code-fold=\"true\"}\nimport pandas as pd\nfrom sympy import *\nfrom sympy.logic import SOPform\nfrom sympy.logic.boolalg import to_cnf, to_dnf\nfrom IPython.display import Markdown, Latex\n\ndf = pd.read_csv('Wahrheitstabelle.csv',sep=';')\ndisplay(Markdown(df.to_markdown(index=False, colalign ='left')))\n```\n\n::: {.cell-output .cell-output-display}\n|   D |   C |   B |   A |   Y |\n|-----|-----|-----|-----|----:|\n| 0   | 0   | 0   | 0   |   0 |\n| 0   | 0   | 0   | 1   |   1 |\n| 0   | 0   | 1   | 0   |   0 |\n| 0   | 0   | 1   | 1   |   1 |\n| 0   | 1   | 0   | 0   |   0 |\n| 0   | 1   | 0   | 1   |   1 |\n| 0   | 1   | 1   | 0   |   1 |\n| 0   | 1   | 1   | 1   |   1 |\n| 1   | 0   | 0   | 0   |   0 |\n| 1   | 0   | 0   | 1   |   1 |\n| 1   | 0   | 1   | 0   |   0 |\n| 1   | 0   | 1   | 1   |   1 |\n| 1   | 1   | 0   | 0   |   1 |\n| 1   | 1   | 0   | 1   |   1 |\n| 1   | 1   | 1   | 0   |   0 |\n| 1   | 1   | 1   | 1   |   0 |\n:::\n:::\n\n\n::: {.callout-note}\n$\\bar{A} = \\neg A$\n::: \n\n::: {.cell execution_count=3}\n``` {.python .cell-code code-fold=\"true\"}\nD = MySymbol('D',description='D Eingang')\nC = MySymbol('C',description='C Eingang')\nB = MySymbol('B',description='B Eingang')\nA = MySymbol('A',description='A Eingang')\nY = MySymbol('Y',description='Y Ausgang')\n\n#D,C,B,A,Y = symbols('D,C,B,A,Y')\n\nmintermsY = df[df['Y'].isin([1])].iloc[:,0:4].values.tolist()\n#Yeq = Eq(Y,POSform([D,C,B,A], mintermsY))\nYeq = Eq(Y,SOPform([D,C,B,A], mintermsY))\n\nQBookHelpers.print_equation(Yeq,label='eq-Yeq')\n\nQBookHelpers.print_description(Yeq.free_symbols)\n```\n\n::: {.cell-output .cell-output-display}\n$$\nY = \\left(A \\wedge \\neg C\\right) \\vee \\left(A \\wedge \\neg D\\right) \\vee \\left(B \\wedge C \\wedge \\neg D\\right) \\vee \\left(C \\wedge D \\wedge \\neg B\\right)\n$${#eq-Yeq}\n:::\n\n::: {.cell-output .cell-output-display}\n$A$ ... A Eingang\n:::\n\n::: {.cell-output .cell-output-display}\n$D$ ... D Eingang\n:::\n\n::: {.cell-output .cell-output-display}\n$C$ ... C Eingang\n:::\n\n::: {.cell-output .cell-output-display}\n$B$ ... B Eingang\n:::\n\n::: {.cell-output .cell-output-display}\n$Y$ ... Y Ausgang\n:::\n:::\n\n\n@eq-bool2 und @eq-Yeq stimmen überein, daher ist davon auszugehen, dass das Ergebnis stimmt. \n\n### Schaltung  \n::: {.callout-note}\nEs handelt sich um eine automatisch generierte Schaltung mit amerikanischen Symbolen! Diese Schaltung entspricht NICHT europäischen Normen und ist rein informativ.\n:::\n\n::: {.cell execution_count=4}\n``` {.python .cell-code code-fold=\"true\"}\nfrom schemdraw.parsing import logicparse\n#https://schemdraw.readthedocs.io/en/latest/elements/logic.html\n\nYeqstring = str(Yeq.rhs).replace('&','and').replace('|','or').replace('~','not ')\n#print(Yeqstring)\nYeqstring = \"(((A and not C) or (A and not D)) or (C and D and not B)) or (B and C and not D)\" #Manuell editiert für besseres grafische Ergebnis\ndisplay(logicparse(Yeqstring, outlabel='$Y$'))\n```\n\n::: {.cell-output .cell-output-display}\n![Logik Schaltung für Ausgang Y](01.05_BoolscheAlgebra_files/figure-html/fig-schaltungs1-output-1.svg){#fig-schaltungs1}\n:::\n:::\n\n\n",
    "supporting": [
      "01.05_BoolscheAlgebra_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}