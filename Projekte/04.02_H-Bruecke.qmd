```{python}
#| code-fold: true
#| echo: false

import pandas as pd
from plotly.subplots import make_subplots
import plotly.express as px
import plotly.graph_objects as go

def trans_plot(filepath, thing_to_plot):
    df = pd.read_csv(filepath,sep=';',decimal=',')

    for key in thing_to_plot:
        suplotnumber_max = 0
        if max(thing_to_plot[key]) > 0:
            suplotnumber_max = max(thing_to_plot[key])

    fig = make_subplots(
        rows=suplotnumber_max, cols=1,
    )

    for key in thing_to_plot:
        for i in thing_to_plot[key]:
            fig.add_trace(go.Scatter(x=df.time.values, y=df[key].values,name=key), row=thing_to_plot[key][0], col=1)
            fig.update_xaxes(title_text=None, tickformat = ".3s", ticksuffix="s",  row=thing_to_plot[key][0], col=1)
            if key[0] == 'v':
                ticksuff = 'V'
            elif key[0] == 'i':
                ticksuff = 'A'
            else:
                ticksuff = ''
            fig.update_yaxes(title=key, ticksuffix=ticksuff,tickformat = ".3s", row=thing_to_plot[key][0], col=1)

    fig.update_layout(
        hovermode="x unified",
        legend_title=None,

        font=dict(
            family="Arial",
            size=12,
            color="black"
        ),
        legend=dict(
            orientation="h",
            yanchor="top",
            y=-0.15,
            xanchor="left",
            x=0.01
        ),
        height=1000/8*suplotnumber_max,
        width=800,
    )

    fig.write_image(filepath.replace('.csv','.svg'))
    fig.show()

```


# H-Brücke {#sec-H-Bruecke}  
{{< include ../../../../Common/QuartoBookHelpers/QuartoBookHelpers.qmd >}}
Der Markt für DC-Motoren belief sich im Jahr 2022 auf ca. 20,1 Milliarden US-Dollar und es wurde erwartet, dass sich das Volumen bis 2031 auf 49,3 Milliarden erhöht [@DC-Motor_Market]. Jeder dieser Motoren braucht eine mehr oder weniger komplizierte Ansteuerung. Eine mögliche Ansteuerung soll hier gezeigt werden.

**Ziel**  
Es soll eine Schaltung entworfen werden welche es erlaubt, einen DC-Motor in folgenden Betriebsarten zu betreiben:  

* Linkslauf  
* Rechtslauf   
* Bremsen  

Bei den ersten beiden Punkten soll es Möglich sein, die Drehzahl mittels *Puls-Weiten-Modulation* (PWM) zu ändern.

**Lernziele**  
  
* Strukturiertes aufbereiten einer Aufgabenstellung  
* Auslegung von digitalen Schaltungen  
* Plausibilität und Qualitätsbeurteilung mittels Simulation  
* Hierarchisches Design in Schaltplänen
* Strukturiertes, zeitoptimiertes Dokumentieren der Arbeit  

**Hilfestellung**  

[Hierarchisches Design](https://htlanichstrasse.sharepoint.com/:v:/s/HWE_G1_GoetL_4CHEL_2324/EZasQb_YxYJFhKNIHozMHHEBL6wJfvGr8gDUHmqqvegymg?e=bt8iiY&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D)

## Beschreibung der H-Brücke  

Im einfachsten Fall wird die Stromversorgung, welche eine entsprechende Leistung hat, mit einem Schalter eingeschaltet und der Motor dreht sich. Um einen Motor drehzahlgesteuert zu betreiben, bedarf es ein Steuersignal und der entsprechenden Leistung für den Motor. In den meisten Fällen ist es so, dass das Steuersignal selbst nicht ausreichend Leistung hat, da es aus einem Mikrocontroller kommt.  
Mit Schaltung @fig-n-Channel_switch kann ein Motor drehzahlgesteuert betrieben werden. Der MOSFET verstärkt dabei die Leistung des Steuersignales. Die Leistung wird von der Quelle $U_q$ zur Verfügung gestellt. Allerdings lässt sich dabei die Drehrichtung nicht ändern.  
Um die oben geforderten Betriebszustände zu erreichen, bedarf es der H-Brücke, auch Vier-Quadranten-Steller genannt, in @fig-H-Bruecke. Die punktiert umrandete Schaltung ist dabei das Ersatzschaltbild eines DC-Motors.

![H-Brücke [@HBruecke] ](Grafiken/Hbruecke/Vierquadrantensteller.png){#fig-H-Bruecke}

### Funktionsweise
Für die Erklärung der Funktionsweise werden die MOSFET's durch gedachte Schalter ersetzt. Dies ist Zulässig, da der MOSFET als Schalter betrieben werden kann. Siehe dazu @sec-MOSFET. 

![Ersatzschaltbild H-Brücke mit Schaltern ](Grafiken/Hbruecke/MitSchaltern.png){#fig-H-BrueckeMS}

$S_1, S_2, S_ 3$ und $S_4$ stellen dabei Potentiale dar. Zur Erinnerung, ein MOSFET schaltet wenn die Spannung zwischen Gate und Source, $U_{GS}$, die Threshold-Spannung $U_{GS,Threshold}$ überschreitet. In Bild @fig-H-BrueckeMS sind alle Schalter offen. Da es sich um N-Kanal Selbstsperrende MOSFET handelt müssen, für diesen Zustand, alle Potentiale, $S_1$ bis $S_4$, $0 \ \mathrm{V}$ sein.

Der Trick ist, den Stromfluss durch den Motor für Rechtslauf und Linkslauf umzukehren. Dies gelingt wie folgt.

#### Linkslauf

![Ersatzschaltbild H-Brücke mit Schaltern, Linkslauf ](Grafiken/Hbruecke/MitSchalternLL.png){#fig-H-BrueckeMSLL}

Potential $S_2$ und $S_3$ müssen auf HIGH sein. Potential $S_1$ und $S_4$ müssen auf LOW sein.


#### Rechtslauf

![Ersatzschaltbild H-Brücke mit Schaltern, Rechtslauf ](Grafiken/Hbruecke/MitSchalternRL.png){#fig-H-BrueckeMSRL}

Potential $S_1$ und $S_4$ müssen auf HIGH sein. Potential $S_2$ und $S_3$ müssen auf LOW sein.

#### Bremsen  

Um den Motor zu bremsen muss er Kurzgeschlossen werden. Daraus ergibt sich, dass Potential $S_2$ und $S_4$ auf HIGH sind und Potential $S_1$ und $S_3$  auf LOW sind.

![Ersatzschaltbild H-Brücke mit Schaltern, Bremsen ](Grafiken/Hbruecke/MitSchalternBremse.png){#fig-H-BrueckeMSBremse}


## Entwicklung der Logik
### Von der Wahrheitstabelle zur Booleschen Gleichung
Zunächst muss in der Zuordnungstabelle der Zusammenhang zwischen dem logischen Zustand und dem physikalischen Wert definiert werden.

|Eingang / Ausgang|Bezeichnung|Zuordnung|Beschreibung|
|:----|:----|:----|:----|
|Eingang|E ... Enable|0 … Disabled;  1 … Enabled|Damit wird die Schaltung Betriebsbereit, Ist Enable deaktiviert kann an den anderen Eingängen ein beliebiges Signal anliegen, der Motor darf sich trotzdem nicht bewegen.|
|Eingang|B ... Break|0 … Disabled; 1 … Enabled|Aktivierung des Bremsbetriebs. Hat Vorrang über die Richtungswahl.|
|Eingang|D ... Direction|0 … Linkslauf; 1 … Rechtslauf|Gibt die Drehrichtung vor.|
|Eingang|P ... PWM|PWM Signal|Gibt die Drehzahl vor.|
|Ausgänge|S1, S2, S3, S4|0 … MOSFET aus; 1 … MOSFET ein|PWM Signal für die Transistoren.|

: Zuordnungstabelle {#tbl-Zuordnung}  

In der Wahrheitstabelle wird nun der Schaltzustand der Ausgänge in Abhängigkeit der Eingänge definiert.  

```{python}
#| code-fold: true
#| echo: false
#| label: #tbl-Wahrheitstabelle
#| tbl-cap: Wahrheitstabelle

import pandas as pd

df = pd.read_csv('HBrücke_Wahrheitstabelle.csv',sep=';')

display(Markdown(df.to_markdown(index=False,tablefmt="github", colalign ='center')))


```

Mittels KV-Diagram oder Boolescher Algebra kann aus der Wahrheitstabelle die einfachste Boolesche Gleichung ermittelt werden. 

::: {.callout-note}
$\bar{A} = \neg A$
:::  

```{python}
#| code-fold: true
#| echo: false


from sympy.logic import SOPform
from sympy.logic.boolalg import to_cnf, to_dnf


PWM = MySymbol('P',description='PWM Eingang')
Enable = MySymbol('E',description='Enable Eingang')
Break = MySymbol('B',description='Break Eingang')
Direction = MySymbol('D',description='Direction Eingang')
Eingaenge = [PWM, Enable, Direction, Break]

S1 = MySymbol('S1',description='Steuersignal Transistor 1')
mintermsS1 = df[df['S1'].isin([1])].iloc[:,0:4].values.tolist()
#display(Eq(S1,POSform(Eingaenge, mintermsS1)))
S1eq = Eq(S1,SOPform(Eingaenge, mintermsS1))
display(S1eq)

S2 = MySymbol('S2',description='Steuersignal Transistor 2')
mintermsS2 = df[df['S2'].isin([1])].iloc[:,0:4].values.tolist()
S2eq = Eq(S2,(POSform(Eingaenge, mintermsS2)))
display(S2eq)
#display(Eq(S2,to_cnf(SOPform(Eingaenge, mintermsS2),simplify=True)))

S3 = MySymbol('S3',description='Steuersignal Transistor 3')
mintermsS3 = df[df['S3'].isin([1])].iloc[:,0:4].values.tolist()
#display(Eq(S3,POSform(Eingaenge, mintermsS3)))
S3eq = Eq(S3,SOPform(Eingaenge, mintermsS3))
display(S3eq)

S4 = MySymbol('S4',description='Steuersignal Transistor 4')
mintermsS4 = df[df['S4'].isin([1])].iloc[:,0:4].values.tolist()
S4eq = Eq(S4,POSform(Eingaenge, mintermsS4))
display(S4eq)
#display(Eq(S4,SOPform(Eingaenge, mintermsS4)))

```

Zur Überprüfung wird aus den Gleichungen die Wahrheitstabelle erstellt und mit der oben definierten Wahrheitstabelle verglichen.  

```{python}

```{python}
#| code-fold: true
#| echo: false
#| label: tbl-WahrheitstabelleKont
#| tbl-cap: Wahrheitstabelle Kontrolle

from sympy.logic.boolalg import truth_table

#print(S1eq.rhs.free_symbols)

#S1
table = truth_table(S1eq.rhs, Eingaenge)
tt = []
tt1 = []
for t in table:
    tt.append(t[0])
    bo = int(t[1] == True)
    tt1.append(bo)
df1 = pd.DataFrame(tt, columns=Eingaenge)
df1 = df1.assign(S1=tt1)

#S2
table = truth_table(S2eq.rhs, Eingaenge)
tt2 = []
for t in table:
    bo = int(t[1] == True)
    tt2.append(bo)
df1 = df1.assign(S2=tt2)

#S2
table = truth_table(S3eq.rhs, Eingaenge)
tt3 = []
for t in table:
    bo = int(t[1] == True)
    tt3.append(bo)
df1 = df1.assign(S3=tt3)

#S4
table = truth_table(S4eq.rhs, Eingaenge)
tt4 = []
for t in table:
    bo = int(t[1] == True)
    tt4.append(bo)
df1 = df1.assign(S4=tt4)

display(Markdown(df1.to_markdown(index=False,tablefmt="github", colalign ='center')))

```


Die Tabellen stimmen überein. Die Gleichungen sind somit richtig.

### Schaltung
Die Logik kann mit verschiedenen Technologien umgesetzt werden. Hier wurde eine Lösung mittels TTL Gattern gewählt. Die Schaltung ist in @fig-LogikSchaltung dargestellt. In einer modernen Anwendung würde die Logik mittels Mikrocontroller realisiert werden. Quartus oder PSoC creator bieten hier Lösungen an. In Quartus lässt sich die Logik aus simulieren.

::: {.callout-note}
Aus wirtschaftlichen Gründen sollte eine Logikschaltung aus möglichst wenigen verschiedenen Logikgattern bestehen. Es bietet sich an, die Schaltung mit NAND oder NOR Gattern aufzubauen. Aus zeitgründen wird im Moment hier darauf verzichtet. Mit der Regel von DeMorgan kann die Schaltung in die jeweilige schreibweise übergeführt werden.
$$\overline{A \land B} = \overline{A} \lor  \overline{B}$$
$$\overline{A \lor B} = \overline{A} \land  \overline{B}$$
:::


<!--
::: {.callout-note}
Es handelt sich um eine automatisch generierte Schaltung mit amerikanischen Symbolen! Diese Schaltung entspricht NICHT europäischen Normen und ist rein informativ.
:::

```{python}
#| code-fold: true
#| echo: false
#| label: fig-SchaltungS1
#| tbl-cap: Logik Schaltung für Steuersignal S1
#| 
from schemdraw.parsing import logicparse
#https://schemdraw.readthedocs.io/en/latest/elements/logic.html

S1string = str(S1eq.rhs).replace('&','and').replace('|','or').replace('~','not ')
display(logicparse(S1string, outlabel='$S1$'))
#display(logicparse('((B and E) and P) and not D', outlabel='$S1$'))

S2string = str(S2eq.rhs).replace('&','and').replace('|','or').replace('~','not ')
display(logicparse(S2string, outlabel='$S2$'))

S3string = str(S3eq.rhs).replace('&','and').replace('|','or').replace('~','not ')
display(logicparse(S3string, outlabel='$S3$',gateH=1.2))

S4string = str(S4eq.rhs).replace('&','and').replace('|','or').replace('~','not ')
display(logicparse(S4string, outlabel='$S4$'))

```
-->


![Logikschaltung mit TTL ](Grafiken/Hbruecke/LogicCirciut.png){#fig-LogikSchaltung}

Mittels simulation kann die Funktion der Schaltung überprüft werden. Dazu wird der zeitliche verlauf mit der Wahrheitstabelle verglichen. Stimmen die Signale überein, ist die Schaltung richtig.  

:::{ .content-hidden unless-format="html"}
:::{#fig-LogikSchaltungSim}
```{python}
#| code-fold: true
#| echo: false


filepath = 'Grafiken/Hbruecke/Transient Analysis.csv'
thing_to_plot = {'v(vbreak)':[1], 'v(vdirection)':[2], 'v(venable)':[3], 'v(vpwm)':[4], 'v(s1)':[5], 'v(s2)':[6], 'v(s3)':[7], 'v(s4)':[8]}

trans_plot(filepath, thing_to_plot)

```
Simulation Logikschaltung mit TTL
:::
:::

Der Signallaufplan passt mit der Wahrheitstabelle überein. Somit ist davon auszugehen, dass die TTL-Schaltung korrekt umgesetzt wurde.

## Ansteuerung der H-Brücke
Die H-Brücke besteht aus P-Kanal Mosfets und N-Kanal Mosfets. Mosfets werden über den Potentialunterschied zwischen Gate und Source gesteuert. Bei den N-Kanal Mosfets T2 und T4 könnte direkt der Ausgang der Logikschaltung verwendet werden. Bei den P-Kanal Mosfets T1 und T3 ist dies nicht möglich, da die Logikschaltung nicht das geeignete Potential liefern kann. Die P-Kanal Mosfets sperren wenn am Gate die selbe Spannung anliegt wie am Source Eingang. Sie leiten wenn am Gate Ground anliegt. Es muss also eine Schaltung entworfen werden, welche die Potentiale anpasst. Aus der obigen Überlegung ergibt sich folgende Anforderung an die Pegelanpassung.

| Ausgang TTL S1 und S3 | Potential am Source Eingang |
|----------|----------|
| 0 V   | $U_s$  |
| 5 V   | 0 V  |

Diese Anpassung lässt sich mittels OPV's realisieren, welche mit der Zwischenkreisspannung, diese liegt am Source Eingang von T1 und T3 an, und Ground versorgt werden. Das TTL Signal wird am negativen Eingang des OPV angelegt um die invertierung zu erreichen. Der OPV verstärkt das Signal und liefert am Ausgang das gewünschte Potential. Die Schaltung ist in @fig-OPV-Schaltung dargestellt. Da das Ausgangssignal der TTL Schaltung nicht genau 0 V beträgt wird am positiven Eingang eine Referenzspannung von 2 V angelegt. Als OPV's müssen Rail to Rail OPV's verwendet werden. Diese können bis auf 0 V herunter schalten. Werden andere verwendet schalten die Mosfets nicht ganz durch und es kommt zu Leistungsverlusten.

![OPV Schaltung ](Grafiken/Hbruecke/OPV-Schaltung.png){#fig-OPV-Schaltung}

## Simulation der H-Brücke
Will man nun die Funktion der H-Brücke simulieren, muss die Logikschaltung mit der Pegelanpassung, die H-Brücke und das Motormodel zusammengeführt werden. Die Schaltung ist in @fig-TopSheet dargestellt. Der Motor kann über das einfache Modell @fig-SimpleMotorModel simuliert werden. Das erweiterte Modell @fig-ExtendedMotorModel liefert auch Informationen über die Drehzahl und das Massenträgheitsmoment, damit kann auch der Bremsvorgang betrachtet werden.

![Zusammengeführte Schaltung ](Grafiken/Hbruecke/TopSheet.png){#fig-TopSheet}  

![Einfaches Motormodel ](Grafiken/Hbruecke/SimpleMotorModel.png){#fig-SimpleMotorModel height=50%}

![Erweitertes Motormodel, @MotorModel ](Grafiken/Hbruecke/AdvancedMotorModel.png){#fig-ExtendedMotorModel width=80%}

Nun können die Betriebzustände simuliert werden. Die Simulation ist in @fig-BridgeSim dargestellt. Die Simulation zeigt, dass die H-Brücke wie gewünscht funktioniert. Die Drehzahl lässt sich mittels PWM verändern. Die Drehrichtung lässt sich mittels D ändern. Die Bremsfunktion lässt sich mittels B aktivieren. 

::: {#nte-noteAltiumSim .callout-note}
Nicht alle Betriebszustände konnten mit Altium simuliert werden wenn sowohl die Logik als auch die H-Brücke mit Motormodel berücksichtig wurde. Speziell das höherfrequente PWM Signal führte zu Fehlern in der Simulation. Auch konnte die Drehrichtung bei verwendung des erweiterten Motormodells nicht gewechselt werden, ohne einen Fehler in der Simulation zu verursachen. Jeder Hinweis zu einer Lösung des Problems wird dankend entgegen genommen!
:::


:::{ .content-hidden unless-format="html"}
:::{#fig-BridgeSim}
```{python}
#| code-fold: true
#| echo: false


filepath = 'Grafiken/Hbruecke/Transient AnalysisLeftRightBreak.csv'
thing_to_plot = {'v(vbreak)':[1], 'v(vdirection)':[2], 'v(venable)':[3], 'i(l_motor)':[4]}

trans_plot(filepath, thing_to_plot)

```
Simulation Brücke  Linkslauf, Rechtslauf und Bremsen
:::
:::

Aufgrund der oben beschriebenen Sitaution in Altium wird der einfluss von PWM, hochfrequente Schaltvorgänge, getrennt betrachtet. 

## PWM und induktive Lasten

**To Be Continued**