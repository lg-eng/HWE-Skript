

# H-Brücke {#sec-H-Bruecke}  
{{< include ../../../../Common/QuartoBookHelpers/QuartoBookHelpers.qmd >}}
Der Markt für DC-Motoren belief sich im Jahr 2022 auf ca. 20,1 Milliarden US-Dollar und es wurde erwartet, dass sich das Volumen bis 2031 auf 49,3 Milliarden erhöht [@DC-Motor_Market]. Jeder dieser Motoren braucht eine mehr oder weniger komplizierte Ansteuerung. Eine mögliche Ansteuerung soll hier gezeigt werden.

**Ziel**  
Es soll eine Schaltung entworfen werden welche es erlaubt, einen DC-Motor in folgenden Betriebsarten zu betreiben:  

* Linkslauf  
* Rechtslauf   
* Bremsen  

Bei den ersten beiden Punkten soll es Möglich sein, die Drehzahl mittels *Puls-Weiten-Modulation* (PWM) zu ändern.

**Lernziele**  
  
* Strukturiertes aufbereiten einer Aufgabenstellung  
* Auslegung von digitalen Schaltungen  
* Plausibilität und Qualitätsbeurteilung mittels Simulation  
* Hierarchisches Design in Schaltplänen
* Strukturiertes, zeitoptimiertes Dokumentieren der Arbeit  

**Hilfestellung**  

[Hierarchisches Design](https://htlanichstrasse.sharepoint.com/:v:/s/HWE_G1_GoetL_4CHEL_2324/EZasQb_YxYJFhKNIHozMHHEBL6wJfvGr8gDUHmqqvegymg?e=bt8iiY&nav=eyJyZWZlcnJhbEluZm8iOnsicmVmZXJyYWxBcHAiOiJTdHJlYW1XZWJBcHAiLCJyZWZlcnJhbFZpZXciOiJTaGFyZURpYWxvZy1MaW5rIiwicmVmZXJyYWxBcHBQbGF0Zm9ybSI6IldlYiIsInJlZmVycmFsTW9kZSI6InZpZXcifX0%3D)

## Beschreibung der H-Brücke  

Im einfachsten Fall wird die Stromversorgung, welche eine entsprechende Leistung hat, mit einem Schalter eingeschaltet und der Motor dreht sich. Um einen Motor drehzahlgesteuert zu betreiben, bedarf es ein Steuersignal und der entsprechenden Leistung für den Motor. In den meisten Fällen ist es so, dass das Steuersignal selbst nicht ausreichend Leistung hat, da es aus einem Mikrocontroller kommt.  
Mit Schaltung @fig-n-Channel_switch kann ein Motor drehzahlgesteuert betrieben werden. Der MOSFET verstärkt dabei die Leistung des Steuersignales. Die Leistung wird von der Quelle $U_q$ zur Verfügung gestellt. Allerdings lässt sich dabei die Drehrichtung nicht ändern.  
Um die oben geforderten Betriebszustände zu erreichen, bedarf es der H-Brücke, auch Vier-Quadranten-Steller genannt, in @fig-H-Bruecke. Die punktiert umrandete Schaltung ist dabei das Ersatzschaltbild eines DC-Motors.

![H-Brücke [@HBruecke] ](Grafiken/Hbruecke/Vierquadrantensteller.png){#fig-H-Bruecke}

### Funktionsweise
Für die Erklärung der Funktionsweise werden die MOSFET's durch gedachte Schalter ersetzt. Dies ist Zulässig, da der MOSFET als Schalter betrieben werden kann. Siehe dazu @sec-MOSFET. 

![Ersatzschaltbild H-Brücke mit Schaltern ](Grafiken/Hbruecke/MitSchaltern.png){#fig-H-BrueckeMS}

$S_1, S_2, S_ 3$ und $S_4$ stellen dabei Potentiale dar. Zur Erinnerung, ein MOSFET schaltet wenn die Spannung zwischen Gate und Source, $U_{GS}$, die Threshold-Spannung $U_{GS,Threshold}$ überschreitet. In Bild @fig-H-BrueckeMS sind alle Schalter offen. Da es sich um N-Kanal Selbstsperrende MOSFET handelt müssen, für diesen Zustand, alle Potentiale, $S_1$ bis $S_4$, $0 \ \mathrm{V}$ sein.

Der Trick ist, den Stromfluss durch den Motor für Rechtslauf und Linkslauf umzukehren. Dies gelingt wie folgt.

#### Linkslauf

![Ersatzschaltbild H-Brücke mit Schaltern, Linkslauf ](Grafiken/Hbruecke/MitSchalternLL.png){#fig-H-BrueckeMSLL}

Potential $S_2$ und $S_3$ müssen auf HIGH sein. Potential $S_1$ und $S_4$ müssen auf LOW sein.


#### Rechtslauf

![Ersatzschaltbild H-Brücke mit Schaltern, Rechtslauf ](Grafiken/Hbruecke/MitSchalternRL.png){#fig-H-BrueckeMSRL}

Potential $S_1$ und $S_4$ müssen auf HIGH sein. Potential $S_2$ und $S_3$ müssen auf LOW sein.

#### Bremsen  

Um den Motor zu bremsen muss er Kurzgeschlossen werden. Daraus ergibt sich, dass Potential $S_2$ und $S_4$ auf HIGH sind und Potential $S_1$ und $S_3$  auf LOW sind.

![Ersatzschaltbild H-Brücke mit Schaltern, Bremsen ](Grafiken/Hbruecke/MitSchalternBremse.png){#fig-H-BrueckeMSBremse}


## Entwicklung der Logik
Zunächst muss in der Zuordnungstabelle der Zusammenhang zwischen dem logischen Zustand und dem physikalischen Wert definiert werden.

|Eingang / Ausgang|Bezeichnung|Zuordnung|Beschreibung|
|:----|:----|:----|:----|
|Eingang|E ... Enable|0 … Disabled;  1 … Enabled|Damit wird die Schaltung Betriebsbereit, Ist Enable deaktiviert kann an den anderen Eingängen ein beliebiges Signal anliegen, der Motor darf sich trotzdem nicht bewegen.|
|Eingang|B ... Break|0 … Disabled; 1 … Enabled|Aktivierung des Bremsbetriebs. Hat Vorrang über die Richtungswahl.|
|Eingang|D ... Direction|0 … Linkslauf; 1 … Rechtslauf|Gibt die Drehrichtung vor.|
|Eingang|P ... PWM|PWM Signal|Gibt die Drehzahl vor.|
|Ausgänge|S1, S2, S3, S4|0 … MOSFET aus; 1 … MOSFET ein|PWM Signal für die Transistoren.|

: Zuordnungstabelle {#tbl-Zuordnung}  

In der Wahrheitstabelle wird nun der Schaltzustand der Ausgänge in Abhängigkeit der Eingänge definiert.  

```{python}
#| code-fold: true
#| echo: false
#| label: tbl-Wahrheitstabelle
#| tbl-cap: Wahrheitstabelle

import pandas as pd

df = pd.read_csv('HBrücke_Wahrheitstabelle.csv',sep=';')

display(Markdown(df.to_markdown(index=False,tablefmt="github", colalign ='center')))


```

Mittels KV-Diagram oder Boolescher Algebra kann aus der Wahrheitstabelle die einfachste Boolesche Gleichung ermittelt werden. 

::: {.callout-note}
$\bar{A} = \neg A$
:::  

```{python}
#| code-fold: true
#| echo: false


from sympy.logic import SOPform
from sympy.logic.boolalg import to_cnf, to_dnf


PWM = MySymbol('P',description='PWM Eingang')
Enable = MySymbol('E',description='Enable Eingang')
Break = MySymbol('B',description='Break Eingang')
Direction = MySymbol('D',description='Direction Eingang')
Eingaenge = [PWM, Enable, Direction, Break]

S1 = MySymbol('S1',description='Steuersignal Transistor 1')
mintermsS1 = df[df['S1'].isin([1])].iloc[:,0:4].values.tolist()
#display(Eq(S1,POSform(Eingaenge, mintermsS1)))
S1eq = Eq(S1,SOPform(Eingaenge, mintermsS1))
display(S1eq)

S2 = MySymbol('S2',description='Steuersignal Transistor 2')
mintermsS2 = df[df['S2'].isin([1])].iloc[:,0:4].values.tolist()
S2eq = Eq(S2,(POSform(Eingaenge, mintermsS2)))
display(S2eq)
#display(Eq(S2,to_cnf(SOPform(Eingaenge, mintermsS2),simplify=True)))

S3 = MySymbol('S3',description='Steuersignal Transistor 3')
mintermsS3 = df[df['S3'].isin([1])].iloc[:,0:4].values.tolist()
#display(Eq(S3,POSform(Eingaenge, mintermsS3)))
S3eq = Eq(S3,SOPform(Eingaenge, mintermsS3))
display(S3eq)

S4 = MySymbol('S4',description='Steuersignal Transistor 4')
mintermsS4 = df[df['S4'].isin([1])].iloc[:,0:4].values.tolist()
S4eq = Eq(S4,POSform(Eingaenge, mintermsS4))
display(S4eq)
#display(Eq(S4,SOPform(Eingaenge, mintermsS4)))

```

Zur Überpürfung wird aus den Gleichungen die Wahrheitstabelle erstellt und mit der oben definierten Wahrheitstabelle @tbl-Wahrheitstabelle verglichen.  

```{python}

```{python}
#| code-fold: true
#| echo: false
#| label: tbl-WahrheitstabelleKont
#| tbl-cap: Wahrheitstabelle Kontrolle

from sympy.logic.boolalg import truth_table

#print(S1eq.rhs.free_symbols)

#S1
table = truth_table(S1eq.rhs, Eingaenge)
tt = []
tt1 = []
for t in table:
    tt.append(t[0])
    bo = int(t[1] == True)
    tt1.append(bo)
df1 = pd.DataFrame(tt, columns=Eingaenge)
df1 = df1.assign(S1=tt1)

#S2
table = truth_table(S2eq.rhs, Eingaenge)
tt2 = []
for t in table:
    bo = int(t[1] == True)
    tt2.append(bo)
df1 = df1.assign(S2=tt2)

#S2
table = truth_table(S3eq.rhs, Eingaenge)
tt3 = []
for t in table:
    bo = int(t[1] == True)
    tt3.append(bo)
df1 = df1.assign(S3=tt3)

#S4
table = truth_table(S4eq.rhs, Eingaenge)
tt4 = []
for t in table:
    bo = int(t[1] == True)
    tt4.append(bo)
df1 = df1.assign(S4=tt4)

display(Markdown(df1.to_markdown(index=False,tablefmt="github", colalign ='center')))

```


Die Tabellen stimmen überein. Die Gleichungen sind somit richtig.

### Logik Schaltung

<!-- 
::: {.callout-note}
Es handelt sich um eine automatisch generierte Schaltung mit amerikanischen Symbolen! Diese Schaltung entspricht NICHT europäischen Normen und ist rein informativ.
:::

```{python}
#| code-fold: true
#| echo: false
#| label: fig-SchaltungS1
#| tbl-cap: Logik Schaltung für Steuersignal S1
#| 
from schemdraw.parsing import logicparse
#https://schemdraw.readthedocs.io/en/latest/elements/logic.html

S1string = str(S1eq.rhs).replace('&','and').replace('|','or').replace('~','not ')
display(logicparse(S1string, outlabel='$S1$'))
#display(logicparse('((B and E) and P) and not D', outlabel='$S1$'))

S2string = str(S2eq.rhs).replace('&','and').replace('|','or').replace('~','not ')
display(logicparse(S2string, outlabel='$S2$'))

S3string = str(S3eq.rhs).replace('&','and').replace('|','or').replace('~','not ')
display(logicparse(S3string, outlabel='$S3$',gateH=1.2))

S4string = str(S4eq.rhs).replace('&','and').replace('|','or').replace('~','not ')
display(logicparse(S4string, outlabel='$S4$'))


```
-->

Aus wirtschaftlichen Gründen sollte eine Logikschaltung aus möglichst wenigen verschiedenen Logikgattern bestehen. Es bietet sich an die Schaltung mit NAND oder NOR Gattern aufzubauen. 



